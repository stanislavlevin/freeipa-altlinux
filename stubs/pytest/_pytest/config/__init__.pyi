import _pytest.hookspec
import argparse
import enum
import py
import types
from .argparsing import Argument as Argument
from .findpaths import determine_setup as determine_setup
from _pytest._code import ExceptionInfo as ExceptionInfo, filter_traceback as filter_traceback
from _pytest._code.code import _TracebackStyle as _TracebackStyle
from _pytest._io import TerminalWriter as TerminalWriter
from _pytest.compat import final as final, importlib_metadata as importlib_metadata
from _pytest.outcomes import Skipped as Skipped, fail as fail
from _pytest.pathlib import ImportMode as ImportMode, bestrelpath as bestrelpath, import_path as import_path
from _pytest.store import Store as Store
from _pytest.terminal import TerminalReporter as TerminalReporter
from _pytest.warning_types import PytestConfigWarning as PytestConfigWarning
from pathlib import Path
from pluggy import PluginManager
from types import TracebackType
from typing import Any, Callable, Generator, Iterable, Iterator, List, Optional, Sequence, TextIO, Tuple, Type, Union

_PluggyPlugin = object
hookimpl: Any
hookspec: Any

class ExitCode(enum.IntEnum):
    OK: int = ...
    TESTS_FAILED: int = ...
    INTERRUPTED: int = ...
    INTERNAL_ERROR: int = ...
    USAGE_ERROR: int = ...
    NO_TESTS_COLLECTED: int = ...

class ConftestImportFailure(Exception):
    path: Any = ...
    excinfo: Any = ...
    def __init__(self, path: py.path.local, excinfo: Tuple[Type[Exception], Exception, TracebackType]) -> None: ...
    def __str__(self) -> str: ...

def filter_traceback_for_conftest_import_failure(entry: _pytest._code.TracebackEntry) -> bool: ...
def main(args: Optional[Union[List[str], py.path.local]]=..., plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]=...) -> Union[int, ExitCode]: ...
def console_main() -> int: ...

class cmdline:
    main: Any = ...

def filename_arg(path: str, optname: str) -> str: ...
def directory_arg(path: str, optname: str) -> str: ...

essential_plugins: Any
default_plugins: Any
builtin_plugins: Any

def get_config(args: Optional[List[str]]=..., plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]=...) -> Config: ...
def get_plugin_manager() -> PytestPluginManager: ...
def _prepareconfig(args: Optional[Union[py.path.local, List[str]]]=..., plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]=...) -> Config: ...

class PytestPluginManager(PluginManager):
    _conftest_plugins: Any = ...
    _dirpath2confmods: Any = ...
    _conftestpath2mod: Any = ...
    _confcutdir: Any = ...
    _noconftest: bool = ...
    _duplicatepaths: Any = ...
    skipped_plugins: Any = ...
    rewrite_hook: Any = ...
    _configured: bool = ...
    def __init__(self) -> None: ...
    def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str) -> Any: ...
    def parse_hookspec_opts(self, module_or_class: Any, name: str) -> Any: ...
    def register(self, plugin: _PluggyPlugin, name: Optional[str]=...) -> Optional[str]: ...
    def getplugin(self, name: str) -> Any: ...
    def hasplugin(self, name: str) -> bool: ...
    def pytest_configure(self, config: Config) -> None: ...
    _using_pyargs: Any = ...
    def _set_initial_conftests(self, namespace: argparse.Namespace) -> None: ...
    def _try_load_conftest(self, anchor: py.path.local, importmode: Union[str, ImportMode]) -> None: ...
    def _getconftestmodules(self, path: py.path.local, importmode: Union[str, ImportMode]) -> List[types.ModuleType]: ...
    def _rget_with_confmod(self, name: str, path: py.path.local, importmode: Union[str, ImportMode]) -> Tuple[types.ModuleType, Any]: ...
    def _importconftest(self, conftestpath: py.path.local, importmode: Union[str, ImportMode]) -> types.ModuleType: ...
    def _check_non_top_pytest_plugins(self, mod: types.ModuleType, conftestpath: py.path.local) -> None: ...
    def consider_preparse(self, args: Sequence[str], *, exclude_only: bool=...) -> None: ...
    def consider_pluginarg(self, arg: str) -> None: ...
    def consider_conftest(self, conftestmodule: types.ModuleType) -> None: ...
    def consider_env(self) -> None: ...
    def consider_module(self, mod: types.ModuleType) -> None: ...
    def _import_plugin_specs(self, spec: Union[None, types.ModuleType, str, Sequence[str]]) -> None: ...
    def import_plugin(self, modname: str, consider_entry_points: bool=...) -> None: ...

def _get_plugin_specs_as_list(specs: Union[None, types.ModuleType, str, Sequence[str]]) -> List[str]: ...
def _ensure_removed_sysmodule(modname: str) -> None: ...

class Notset:
    def __repr__(self): ...

notset: Any

def _iter_rewritable_modules(package_files: Iterable[str]) -> Iterator[str]: ...
def _args_converter(args: Iterable[str]) -> Tuple[str, ...]: ...

class Config:
    class InvocationParams:
        args: Any = ...
        plugins: Any = ...
        dir: Any = ...
        def __init__(self, args: Any, plugins: Any, dir: Any) -> None: ...
        def __lt__(self, other: Any) -> Any: ...
        def __le__(self, other: Any) -> Any: ...
        def __gt__(self, other: Any) -> Any: ...
        def __ge__(self, other: Any) -> Any: ...
    option: Any = ...
    invocation_params: Any = ...
    _parser: Any = ...
    pluginmanager: Any = ...
    trace: Any = ...
    hook: Any = ...
    _inicache: Any = ...
    _override_ini: Any = ...
    _opt2dest: Any = ...
    _cleanup: Any = ...
    _store: Any = ...
    _configured: bool = ...
    cache: Any = ...
    def __init__(self, pluginmanager: PytestPluginManager, *, invocation_params: Optional[InvocationParams]=...) -> None: ...
    @property
    def invocation_dir(self) -> py.path.local: ...
    @property
    def rootpath(self) -> Path: ...
    @property
    def rootdir(self) -> py.path.local: ...
    @property
    def inipath(self) -> Optional[Path]: ...
    @property
    def inifile(self) -> Optional[py.path.local]: ...
    def add_cleanup(self, func: Callable[[], None]) -> None: ...
    def _do_configure(self) -> None: ...
    def _ensure_unconfigure(self) -> None: ...
    def get_terminal_writer(self) -> TerminalWriter: ...
    def pytest_cmdline_parse(self, pluginmanager: PytestPluginManager, args: List[str]) -> Config: ...
    def notify_exception(self, excinfo: ExceptionInfo[BaseException], option: Optional[argparse.Namespace]=...) -> None: ...
    def cwd_relative_nodeid(self, nodeid: str) -> str: ...
    @classmethod
    def fromdictargs(cls: Any, option_dict: Any, args: Any) -> Config: ...
    def _processopt(self, opt: Argument) -> None: ...
    def pytest_load_initial_conftests(self, early_config: Config) -> None: ...
    _rootpath: Any = ...
    _inipath: Any = ...
    inicfg: Any = ...
    def _initini(self, args: Sequence[str]) -> None: ...
    def _consider_importhook(self, args: Sequence[str]) -> None: ...
    def _mark_plugins_for_rewrite(self, hook: Any) -> None: ...
    def _validate_args(self, args: List[str], via: str) -> List[str]: ...
    known_args_namespace: Any = ...
    def _preparse(self, args: List[str], addopts: bool=...) -> None: ...
    def pytest_collection(self) -> Generator[None, None, None]: ...
    def _checkversion(self) -> None: ...
    def _validate_config_options(self) -> None: ...
    def _validate_plugins(self) -> None: ...
    def _warn_or_fail_if_strict(self, message: str) -> None: ...
    def _get_unknown_ini_keys(self) -> List[str]: ...
    args: Any = ...
    def parse(self, args: List[str], addopts: bool=...) -> None: ...
    def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None: ...
    def addinivalue_line(self, name: str, line: str) -> None: ...
    def getini(self, name: str) -> Any: ...
    def _getini(self, name: str) -> Any: ...
    def _getconftest_pathlist(self, name: str, path: py.path.local) -> Optional[List[py.path.local]]: ...
    def _get_override_ini_value(self, name: str) -> Optional[str]: ...
    def getoption(self, name: str, default: Any=..., skip: bool=...) -> Any: ...
    def getvalue(self, name: str, path: Any=...) -> Any: ...
    def getvalueorskip(self, name: str, path: Any=...) -> Any: ...
    def _warn_about_missing_assertion(self, mode: str) -> None: ...
    def _warn_about_skipped_plugins(self) -> None: ...

def _assertion_supported() -> bool: ...
def create_terminal_writer(config: Config, file: Optional[TextIO]=...) -> TerminalWriter: ...
def _strtobool(val: str) -> bool: ...
def parse_warning_filter(arg: str, escape: bool) -> Tuple[str, str, Type[Warning], str, int]: ...
def apply_warning_filters(config_filters: Iterable[str], cmdline_filters: Iterable[str]) -> None: ...
