import doctest
import py.path
import pytest
from _pytest import outcomes as outcomes
from _pytest._code.code import ExceptionInfo as ExceptionInfo, ReprFileLocation as ReprFileLocation, TerminalRepr as TerminalRepr
from _pytest._io import TerminalWriter as TerminalWriter
from _pytest.compat import safe_getattr as safe_getattr
from _pytest.config import Config as Config
from _pytest.config.argparsing import Parser as Parser
from _pytest.fixtures import FixtureRequest as FixtureRequest
from _pytest.nodes import Collector as Collector
from _pytest.outcomes import OutcomeException as OutcomeException
from _pytest.pathlib import import_path as import_path
from _pytest.python_api import approx as approx
from _pytest.warning_types import PytestWarning as PytestWarning
from typing import Any, Dict, Generator, Iterable, Optional, Sequence, Tuple, Type, Union

DOCTEST_REPORT_CHOICE_NONE: str
DOCTEST_REPORT_CHOICE_CDIFF: str
DOCTEST_REPORT_CHOICE_NDIFF: str
DOCTEST_REPORT_CHOICE_UDIFF: str
DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE: str
DOCTEST_REPORT_CHOICES: Any
RUNNER_CLASS: Any
CHECKER_CLASS: Optional[Type[doctest.OutputChecker]]

def pytest_addoption(parser: Parser) -> None: ...
def pytest_unconfigure() -> None: ...
def pytest_collect_file(path: py.path.local, parent: Collector) -> Optional[Union[DoctestModule, DoctestTextfile]]: ...
def _is_setup_py(path: py.path.local) -> bool: ...
def _is_doctest(config: Config, path: py.path.local, parent: Any) -> bool: ...

class ReprFailDoctest(TerminalRepr):
    reprlocation_lines: Any = ...
    def __init__(self, reprlocation_lines: Sequence[Tuple[ReprFileLocation, Sequence[str]]]) -> None: ...
    def toterminal(self, tw: TerminalWriter) -> None: ...

class MultipleDoctestFailures(Exception):
    failures: Any = ...
    def __init__(self, failures: Sequence[doctest.DocTestFailure]) -> None: ...

def _init_runner_class() -> Type[doctest.DocTestRunner]: ...
def _get_runner(checker: Optional[doctest.OutputChecker]=..., verbose: Optional[bool]=..., optionflags: int=..., continue_on_failure: bool=...) -> doctest.DocTestRunner: ...

class DoctestItem(pytest.Item):
    runner: Any = ...
    dtest: Any = ...
    obj: Any = ...
    fixture_request: Any = ...
    def __init__(self, name: str, parent: Union[DoctestTextfile, DoctestModule], runner: Optional[doctest.DocTestRunner]=..., dtest: Optional[doctest.DocTest]=...) -> None: ...
    @classmethod
    def from_parent(cls: Any, parent: Union[DoctestTextfile, DoctestModule], name: str, runner: doctest.DocTestRunner, dtest: doctest.DocTest) -> Any: ...
    def setup(self) -> None: ...
    def runtest(self) -> None: ...
    def _disable_output_capturing_for_darwin(self) -> None: ...
    def repr_failure(self, excinfo: ExceptionInfo[BaseException]) -> Union[str, TerminalRepr]: ...
    def reportinfo(self): ...

def _get_flag_lookup() -> Dict[str, int]: ...
def get_optionflags(parent: Any): ...
def _get_continue_on_failure(config: Any): ...

class DoctestTextfile(pytest.Module):
    obj: Any = ...
    def collect(self) -> Iterable[DoctestItem]: ...

def _check_all_skipped(test: doctest.DocTest) -> None: ...
def _is_mocked(obj: object) -> bool: ...
def _patch_unwrap_mock_aware() -> Generator[None, None, None]: ...

class DoctestModule(pytest.Module):
    def collect(self) -> Iterable[DoctestItem]: ...

def _setup_fixtures(doctest_item: DoctestItem) -> FixtureRequest: ...
def _init_checker_class() -> Type[doctest.OutputChecker]: ...
def _get_checker() -> doctest.OutputChecker: ...
def _get_allow_unicode_flag() -> int: ...
def _get_allow_bytes_flag() -> int: ...
def _get_number_flag() -> int: ...
def _get_report_choice(key: str) -> int: ...
def doctest_namespace() -> Dict[str, Any]: ...
