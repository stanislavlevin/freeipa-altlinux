from _pytest import outcomes as outcomes
from _pytest._io.saferepr import _pformat_dispatch as _pformat_dispatch, safeformat as safeformat, saferepr as saferepr
from typing import AbstractSet, Any, Callable, Iterable, List, Mapping, Optional, Sequence

_reprcompare: Optional[Callable[[str, object, object], Optional[str]]]
_assertion_pass: Optional[Callable[[int, str, str], None]]

def format_explanation(explanation: str) -> str: ...
def _split_explanation(explanation: str) -> List[str]: ...
def _format_lines(lines: Sequence[str]) -> List[str]: ...
def issequence(x: Any) -> bool: ...
def istext(x: Any) -> bool: ...
def isdict(x: Any) -> bool: ...
def isset(x: Any) -> bool: ...
def isnamedtuple(obj: Any) -> bool: ...
def isdatacls(obj: Any) -> bool: ...
def isattrs(obj: Any) -> bool: ...
def isiterable(obj: Any) -> bool: ...
def assertrepr_compare(config: Any, op: str, left: Any, right: Any) -> Optional[List[str]]: ...
def _compare_eq_any(left: Any, right: Any, verbose: int=...) -> List[str]: ...
def _diff_text(left: str, right: str, verbose: int=...) -> List[str]: ...
def _compare_eq_verbose(left: Any, right: Any) -> List[str]: ...
def _surrounding_parens_on_own_lines(lines: List[str]) -> None: ...
def _compare_eq_iterable(left: Iterable[Any], right: Iterable[Any], verbose: int=...) -> List[str]: ...
def _compare_eq_sequence(left: Sequence[Any], right: Sequence[Any], verbose: int=...) -> List[str]: ...
def _compare_eq_set(left: AbstractSet[Any], right: AbstractSet[Any], verbose: int=...) -> List[str]: ...
def _compare_eq_dict(left: Mapping[Any, Any], right: Mapping[Any, Any], verbose: int=...) -> List[str]: ...
def _compare_eq_cls(left: Any, right: Any, verbose: int) -> List[str]: ...
def _notin_text(term: str, text: str, verbose: int=...) -> List[str]: ...
