import os
import py
from _pytest import fixtures as fixtures, nodes as nodes
from _pytest._code import filter_traceback as filter_traceback, getfslineno as getfslineno
from _pytest._code.code import ExceptionInfo as ExceptionInfo, TerminalRepr as TerminalRepr
from _pytest._io import TerminalWriter as TerminalWriter
from _pytest._io.saferepr import saferepr as saferepr
from _pytest.compat import NOTSET as NOTSET, REGEX_TYPE as REGEX_TYPE, STRING_TYPES as STRING_TYPES, ascii_escaped as ascii_escaped, final as final, get_default_arg_names as get_default_arg_names, get_real_func as get_real_func, getimfunc as getimfunc, getlocation as getlocation, is_async_function as is_async_function, is_generator as is_generator, safe_getattr as safe_getattr, safe_isclass as safe_isclass
from _pytest.config import Config as Config, ExitCode as ExitCode, hookimpl as hookimpl
from _pytest.config.argparsing import Parser as Parser
from _pytest.deprecated import FSCOLLECTOR_GETHOOKPROXY_ISINITPATH as FSCOLLECTOR_GETHOOKPROXY_ISINITPATH
from _pytest.fixtures import FuncFixtureInfo as FuncFixtureInfo, _Scope as _Scope
from _pytest.main import Session as Session
from _pytest.mark import MARK_GEN as MARK_GEN, ParameterSet as ParameterSet
from _pytest.mark.structures import Mark as Mark, MarkDecorator as MarkDecorator, get_unpacked_marks as get_unpacked_marks, normalize_mark_list as normalize_mark_list
from _pytest.outcomes import fail as fail, skip as skip
from _pytest.pathlib import ImportPathMismatchError as ImportPathMismatchError, import_path as import_path, parts as parts, visit as visit
from _pytest.warning_types import PytestCollectionWarning as PytestCollectionWarning, PytestUnhandledCoroutineWarning as PytestUnhandledCoroutineWarning
from typing import Any, Callable, Dict, Iterable, Iterator, List, Mapping, Optional, Sequence, Tuple, Type, Union
from typing_extensions import Literal as Literal

def pytest_addoption(parser: Parser) -> None: ...
def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]: ...
def pytest_generate_tests(metafunc: Metafunc) -> None: ...
def pytest_configure(config: Config) -> None: ...
def async_warn_and_skip(nodeid: str) -> None: ...
def pytest_pyfunc_call(pyfuncitem: Function) -> Optional[object]: ...
def pytest_collect_file(path: py.path.local, parent: nodes.Collector) -> Optional[Module]: ...
def path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool: ...
def pytest_pycollect_makemodule(path: py.path.local, parent: Any) -> Module: ...
def pytest_pycollect_makeitem(collector: PyCollector, name: str, obj: object) -> Any: ...

class PyobjMixin:
    _ALLOW_MARKERS: bool = ...
    name: str = ...
    parent: Optional[nodes.Node] = ...
    own_markers: List[Mark] = ...
    def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]: ...
    def listchain(self) -> List[nodes.Node]: ...
    @property
    def module(self): ...
    @property
    def cls(self): ...
    @property
    def instance(self): ...
    _obj: Any = ...
    @property
    def obj(self): ...
    @obj.setter
    def obj(self, value: Any) -> None: ...
    def _getobj(self): ...
    def getmodpath(self, stopatmodule: bool=..., includemodule: bool=...) -> str: ...
    def reportinfo(self) -> Tuple[Union[py.path.local, str], int, str]: ...

class _EmptyClass: ...

IGNORED_ATTRIBUTES: Any

class PyCollector(PyobjMixin, nodes.Collector):
    def funcnamefilter(self, name: str) -> bool: ...
    def isnosetest(self, obj: object) -> bool: ...
    def classnamefilter(self, name: str) -> bool: ...
    def istestfunction(self, obj: object, name: str) -> bool: ...
    def istestclass(self, obj: object, name: str) -> bool: ...
    def _matches_prefix_or_glob_option(self, option_name: str, name: str) -> bool: ...
    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]: ...
    def _genfunctions(self, name: str, funcobj: Any) -> Iterator[Function]: ...

class Module(nodes.File, PyCollector):
    def _getobj(self): ...
    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]: ...
    def _inject_setup_module_fixture(self) -> None: ...
    def _inject_setup_function_fixture(self) -> None: ...
    def _importtestmodule(self): ...

class Package(Module):
    name: Any = ...
    def __init__(self, fspath: py.path.local, parent: nodes.Collector, config: Any=..., session: Any=..., nodeid: Any=...) -> None: ...
    def setup(self) -> None: ...
    def gethookproxy(self, fspath: py.path.local) -> Any: ...
    def isinitpath(self, path: py.path.local) -> bool: ...
    def _recurse(self, direntry: os.DirEntry[str]) -> bool: ...
    def _collectfile(self, path: py.path.local, handle_dupes: bool=...) -> Sequence[nodes.Collector]: ...
    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]: ...

def _call_with_optional_argument(func: Any, arg: Any) -> None: ...
def _get_first_non_fixture_func(obj: object, names: Iterable[str]) -> Any: ...

class Class(PyCollector):
    @classmethod
    def from_parent(cls, parent: Any, name: Any, *, obj: Optional[Any] = ...): ...
    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]: ...
    def _inject_setup_class_fixture(self) -> None: ...
    def _inject_setup_method_fixture(self) -> None: ...

class Instance(PyCollector):
    _ALLOW_MARKERS: bool = ...
    def _getobj(self): ...
    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]: ...
    obj: Any = ...
    def newinstance(self): ...

def hasinit(obj: object) -> bool: ...
def hasnew(obj: object) -> bool: ...

class CallSpec2:
    metafunc: Any = ...
    funcargs: Any = ...
    _idlist: Any = ...
    params: Any = ...
    _arg2scopenum: Any = ...
    marks: Any = ...
    indices: Any = ...
    def __init__(self, metafunc: Metafunc) -> None: ...
    def copy(self) -> CallSpec2: ...
    def _checkargnotcontained(self, arg: str) -> None: ...
    def getparam(self, name: str) -> object: ...
    @property
    def id(self) -> str: ...
    def setmulti2(self, valtypes: Mapping[str, Literal[params, funcargs]], argnames: Sequence[str], valset: Iterable[object], id: str, marks: Iterable[Union[Mark, MarkDecorator]], scopenum: int, param_index: int) -> None: ...

class Metafunc:
    definition: Any = ...
    config: Any = ...
    module: Any = ...
    function: Any = ...
    fixturenames: Any = ...
    cls: Any = ...
    _calls: Any = ...
    _arg2fixturedefs: Any = ...
    def __init__(self, definition: FunctionDefinition, fixtureinfo: fixtures.FuncFixtureInfo, config: Config, cls: Any=..., module: Any=...) -> None: ...
    def parametrize(self, argnames: Union[str, List[str], Tuple[str, ...]], argvalues: Iterable[Union[ParameterSet, Sequence[object], object]], indirect: Union[bool, Sequence[str]]=..., ids: Optional[Union[Iterable[Union[None, str, float, int, bool]], Callable[[Any], Optional[object]]]]=..., scope: Optional[_Scope]=..., *, _param_mark: Optional[Mark]=...) -> None: ...
    def _resolve_arg_ids(self, argnames: Sequence[str], ids: Optional[Union[Iterable[Union[None, str, float, int, bool]], Callable[[Any], Optional[object]]]], parameters: Sequence[ParameterSet], nodeid: str) -> List[str]: ...
    def _validate_ids(self, ids: Iterable[Union[None, str, float, int, bool]], parameters: Sequence[ParameterSet], func_name: str) -> List[Union[None, str]]: ...
    def _resolve_arg_value_types(self, argnames: Sequence[str], indirect: Union[bool, Sequence[str]]) -> Dict[str, Literal[params, funcargs]]: ...
    def _validate_if_using_arg_names(self, argnames: Sequence[str], indirect: Union[bool, Sequence[str]]) -> None: ...

def _find_parametrized_scope(argnames: Sequence[str], arg2fixturedefs: Mapping[str, Sequence[fixtures.FixtureDef[object]]], indirect: Union[bool, Sequence[str]]) -> fixtures._Scope: ...
def _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str: ...
def _idval(val: object, argname: str, idx: int, idfn: Optional[Callable[[Any], Optional[object]]], nodeid: Optional[str], config: Optional[Config]) -> str: ...
def _idvalset(idx: int, parameterset: ParameterSet, argnames: Iterable[str], idfn: Optional[Callable[[Any], Optional[object]]], ids: Optional[List[Union[None, str]]], nodeid: Optional[str], config: Optional[Config]) -> str: ...
def idmaker(argnames: Iterable[str], parametersets: Iterable[ParameterSet], idfn: Optional[Callable[[Any], Optional[object]]]=..., ids: Optional[List[Union[None, str]]]=..., config: Optional[Config]=..., nodeid: Optional[str]=...) -> List[str]: ...
def show_fixtures_per_test(config: Any): ...
def _show_fixtures_per_test(config: Config, session: Session) -> None: ...
def showfixtures(config: Config) -> Union[int, ExitCode]: ...
def _showfixtures_main(config: Config, session: Session) -> None: ...
def write_docstring(tw: TerminalWriter, doc: str, indent: str=...) -> None: ...

class Function(PyobjMixin, nodes.Item):
    _ALLOW_MARKERS: bool = ...
    obj: Any = ...
    originalname: Any = ...
    callspec: Any = ...
    _fixtureinfo: Any = ...
    fixturenames: Any = ...
    def __init__(self, name: str, parent: Any, config: Optional[Config]=..., callspec: Optional[CallSpec2]=..., callobj: Any=..., keywords: Any=..., session: Optional[Session]=..., fixtureinfo: Optional[FuncFixtureInfo]=..., originalname: Optional[str]=...) -> None: ...
    @classmethod
    def from_parent(cls, parent: Any, **kw: Any): ...
    funcargs: Any = ...
    _request: Any = ...
    def _initrequest(self) -> None: ...
    @property
    def function(self): ...
    def _getobj(self): ...
    @property
    def _pyfuncitem(self): ...
    def runtest(self) -> None: ...
    def setup(self) -> None: ...
    def _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None: ...
    def repr_failure(self, excinfo: ExceptionInfo[BaseException]) -> Union[str, TerminalRepr]: ...

class FunctionDefinition(Function):
    def runtest(self) -> None: ...
    setup: Any = ...
