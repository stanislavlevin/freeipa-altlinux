import typing
from cryptography import utils as utils
from cryptography.exceptions import UnsupportedAlgorithm as UnsupportedAlgorithm
from cryptography.hazmat.backends import _get_backend as _get_backend
from cryptography.hazmat.primitives.asymmetric import dsa as dsa, ec as ec, ed25519 as ed25519, rsa as rsa
from cryptography.hazmat.primitives.ciphers import Cipher as Cipher, algorithms as algorithms, modes as modes
from cryptography.hazmat.primitives.serialization import Encoding as Encoding, NoEncryption as NoEncryption, PrivateFormat as PrivateFormat, PublicFormat as PublicFormat
from typing import Any, Optional

_bcrypt_supported: bool
_SSH_ED25519: bytes
_SSH_RSA: bytes
_SSH_DSA: bytes
_ECDSA_NISTP256: bytes
_ECDSA_NISTP384: bytes
_ECDSA_NISTP521: bytes
_CERT_SUFFIX: bytes
_SSH_PUBKEY_RC: Any
_SK_MAGIC: bytes
_SK_START: bytes
_SK_END: bytes
_BCRYPT: bytes
_NONE: bytes
_DEFAULT_CIPHER: bytes
_DEFAULT_ROUNDS: int
_MAX_PASSWORD: int
_PEM_RC: Any
_PADDING: Any
_SSH_CIPHERS: Any
_ECDSA_KEY_TYPE: Any
_U32: Any
_U64: Any

def _ecdsa_key_type(public_key: Any): ...
def _ssh_pem_encode(data: Any, prefix: Any = ..., suffix: Any = ...): ...
def _check_block_size(data: Any, block_len: Any) -> None: ...
def _check_empty(data: Any) -> None: ...
def _init_cipher(ciphername: Any, password: Any, salt: Any, rounds: Any, backend: Any): ...
def _get_u32(data: Any): ...
def _get_u64(data: Any): ...
def _get_sshstr(data: Any): ...
def _get_mpint(data: Any): ...
def _to_mpint(val: Any): ...

class _FragList:
    flist: Any = ...
    def __init__(self, init: Optional[Any] = ...) -> None: ...
    def put_raw(self, val: Any) -> None: ...
    def put_u32(self, val: Any) -> None: ...
    def put_sshstr(self, val: Any) -> None: ...
    def put_mpint(self, val: Any) -> None: ...
    def size(self): ...
    def render(self, dstbuf: Any, pos: int = ...): ...
    def tobytes(self): ...

class _SSHFormatRSA:
    def get_public(self, data: Any): ...
    def load_public(self, key_type: Any, data: Any, backend: Any): ...
    def load_private(self, data: Any, pubfields: Any, backend: Any): ...
    def encode_public(self, public_key: Any, f_pub: Any) -> None: ...
    def encode_private(self, private_key: Any, f_priv: Any) -> None: ...

class _SSHFormatDSA:
    def get_public(self, data: Any): ...
    def load_public(self, key_type: Any, data: Any, backend: Any): ...
    def load_private(self, data: Any, pubfields: Any, backend: Any): ...
    def encode_public(self, public_key: Any, f_pub: Any) -> None: ...
    def encode_private(self, private_key: Any, f_priv: Any) -> None: ...
    def _validate(self, public_numbers: Any) -> None: ...

class _SSHFormatECDSA:
    ssh_curve_name: Any = ...
    curve: Any = ...
    def __init__(self, ssh_curve_name: Any, curve: Any) -> None: ...
    def get_public(self, data: Any): ...
    def load_public(self, key_type: Any, data: Any, backend: Any): ...
    def load_private(self, data: Any, pubfields: Any, backend: Any): ...
    def encode_public(self, public_key: Any, f_pub: Any) -> None: ...
    def encode_private(self, private_key: Any, f_priv: Any) -> None: ...

class _SSHFormatEd25519:
    def get_public(self, data: Any): ...
    def load_public(self, key_type: Any, data: Any, backend: Any): ...
    def load_private(self, data: Any, pubfields: Any, backend: Any): ...
    def encode_public(self, public_key: Any, f_pub: Any) -> None: ...
    def encode_private(self, private_key: Any, f_priv: Any) -> None: ...

_KEY_FORMATS: Any

def _lookup_kformat(key_type: Any): ...

_SSH_PRIVATE_KEY_TYPES: Any

def load_ssh_private_key(data: bytes, password: typing.Optional[bytes], backend: Any=...) -> _SSH_PRIVATE_KEY_TYPES: ...
def serialize_ssh_private_key(private_key: _SSH_PRIVATE_KEY_TYPES, password: typing.Optional[bytes]=...) -> Any: ...

_SSH_PUBLIC_KEY_TYPES: Any

def load_ssh_public_key(data: bytes, backend: Any=...) -> _SSH_PUBLIC_KEY_TYPES: ...
def serialize_ssh_public_key(public_key: _SSH_PUBLIC_KEY_TYPES) -> bytes: ...
