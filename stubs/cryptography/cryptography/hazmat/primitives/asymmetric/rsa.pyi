import abc
import typing
from cryptography import utils as utils
from cryptography.exceptions import UnsupportedAlgorithm as UnsupportedAlgorithm, _Reasons as _Reasons
from cryptography.hazmat.backends import _get_backend as _get_backend
from cryptography.hazmat.backends.interfaces import RSABackend as RSABackend
from cryptography.hazmat.primitives import _serialization as _serialization, hashes as hashes
from cryptography.hazmat.primitives._asymmetric import AsymmetricPadding as AsymmetricPadding
from cryptography.hazmat.primitives.asymmetric import AsymmetricSignatureContext as AsymmetricSignatureContext, AsymmetricVerificationContext as AsymmetricVerificationContext, utils as asym_utils
from typing import Any

class RSAPrivateKey(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def signer(self, padding: AsymmetricPadding, algorithm: hashes.HashAlgorithm) -> AsymmetricSignatureContext: ...
    @abc.abstractmethod
    def decrypt(self, ciphertext: bytes, padding: AsymmetricPadding) -> bytes: ...
    @property
    @abc.abstractmethod
    def key_size(self) -> int: ...
    @abc.abstractmethod
    def public_key(self) -> RSAPublicKey: ...
    @abc.abstractmethod
    def sign(self, data: bytes, padding: AsymmetricPadding, algorithm: typing.Union[asym_utils.Prehashed, hashes.HashAlgorithm]) -> bytes: ...
    @abc.abstractmethod
    def private_numbers(self) -> RSAPrivateNumbers: ...
    @abc.abstractmethod
    def private_bytes(self, encoding: _serialization.Encoding, format: _serialization.PrivateFormat, encryption_algorithm: _serialization.KeySerializationEncryption) -> bytes: ...
RSAPrivateKeyWithSerialization = RSAPrivateKey

class RSAPublicKey(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def verifier(self, signature: bytes, padding: AsymmetricPadding, algorithm: hashes.HashAlgorithm) -> AsymmetricVerificationContext: ...
    @abc.abstractmethod
    def encrypt(self, plaintext: bytes, padding: AsymmetricPadding) -> bytes: ...
    @property
    @abc.abstractmethod
    def key_size(self) -> int: ...
    @abc.abstractmethod
    def public_numbers(self) -> RSAPublicNumbers: ...
    @abc.abstractmethod
    def public_bytes(self, encoding: _serialization.Encoding, format: _serialization.PublicFormat) -> bytes: ...
    @abc.abstractmethod
    def verify(self, signature: bytes, data: bytes, padding: AsymmetricPadding, algorithm: typing.Union[asym_utils.Prehashed, hashes.HashAlgorithm]) -> None: ...
    @abc.abstractmethod
    def recover_data_from_signature(self, signature: bytes, padding: AsymmetricPadding, algorithm: typing.Optional[hashes.HashAlgorithm]) -> bytes: ...
RSAPublicKeyWithSerialization = RSAPublicKey

def generate_private_key(public_exponent: int, key_size: int, backend: Any=...) -> RSAPrivateKey: ...
def _verify_rsa_parameters(public_exponent: int, key_size: int) -> None: ...
def _check_private_key_components(p: int, q: int, private_exponent: int, dmp1: int, dmq1: int, iqmp: int, public_exponent: int, modulus: int) -> None: ...
def _check_public_key_components(e: int, n: int) -> None: ...
def _modinv(e: int, m: int) -> int: ...
def rsa_crt_iqmp(p: int, q: int) -> int: ...
def rsa_crt_dmp1(private_exponent: int, p: int) -> int: ...
def rsa_crt_dmq1(private_exponent: int, q: int) -> int: ...

_MAX_RECOVERY_ATTEMPTS: int

def rsa_recover_prime_factors(n: int, e: int, d: int) -> typing.Tuple[int, int]: ...

class RSAPrivateNumbers:
    _p: Any = ...
    _q: Any = ...
    _d: Any = ...
    _dmp1: Any = ...
    _dmq1: Any = ...
    _iqmp: Any = ...
    _public_numbers: Any = ...
    def __init__(self, p: int, q: int, d: int, dmp1: int, dmq1: int, iqmp: int, public_numbers: RSAPublicNumbers) -> None: ...
    p: Any = ...
    q: Any = ...
    d: Any = ...
    dmp1: Any = ...
    dmq1: Any = ...
    iqmp: Any = ...
    public_numbers: Any = ...
    def private_key(self, backend: Any=...) -> RSAPrivateKey: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...

class RSAPublicNumbers:
    _e: Any = ...
    _n: Any = ...
    def __init__(self, e: int, n: int) -> None: ...
    e: Any = ...
    n: Any = ...
    def public_key(self, backend: Any=...) -> RSAPublicKey: ...
    def __repr__(self): ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...
