import typing
from cryptography import utils as utils
from cryptography.exceptions import AlreadyFinalized as AlreadyFinalized, InvalidKey as InvalidKey, UnsupportedAlgorithm as UnsupportedAlgorithm, _Reasons as _Reasons
from cryptography.hazmat.backends import _get_backend as _get_backend
from cryptography.hazmat.backends.interfaces import HMACBackend as HMACBackend, HashBackend as HashBackend
from cryptography.hazmat.primitives import constant_time as constant_time, hashes as hashes, hmac as hmac
from cryptography.hazmat.primitives.kdf import KeyDerivationFunction as KeyDerivationFunction
from typing import Any

def _int_to_u32be(n: int) -> bytes: ...
def _common_args_checks(algorithm: hashes.HashAlgorithm, length: int, otherinfo: typing.Optional[bytes]) -> Any: ...
def _concatkdf_derive(key_material: bytes, length: int, auxfn: typing.Callable[[], hashes.HashContext], otherinfo: bytes) -> bytes: ...

class ConcatKDFHash(KeyDerivationFunction):
    _algorithm: Any = ...
    _length: Any = ...
    _otherinfo: Any = ...
    _backend: Any = ...
    _used: bool = ...
    def __init__(self, algorithm: hashes.HashAlgorithm, length: int, otherinfo: typing.Optional[bytes], backend: Any=...) -> None: ...
    def _hash(self) -> hashes.Hash: ...
    def derive(self, key_material: bytes) -> bytes: ...
    def verify(self, key_material: bytes, expected_key: bytes) -> None: ...

class ConcatKDFHMAC(KeyDerivationFunction):
    _algorithm: Any = ...
    _length: Any = ...
    _otherinfo: Any = ...
    _salt: Any = ...
    _backend: Any = ...
    _used: bool = ...
    def __init__(self, algorithm: hashes.HashAlgorithm, length: int, salt: typing.Optional[bytes], otherinfo: typing.Optional[bytes], backend: Any=...) -> None: ...
    def _hmac(self) -> hmac.HMAC: ...
    def derive(self, key_material: bytes) -> bytes: ...
    def verify(self, key_material: bytes, expected_key: bytes) -> None: ...
