import typing
from cryptography import utils as utils
from cryptography.exceptions import InvalidSignature as InvalidSignature
from cryptography.hazmat.backends import _get_backend as _get_backend
from cryptography.hazmat.primitives import hashes as hashes, padding as padding
from cryptography.hazmat.primitives.ciphers import Cipher as Cipher, algorithms as algorithms, modes as modes
from cryptography.hazmat.primitives.hmac import HMAC as HMAC
from typing import Any

class InvalidToken(Exception): ...

_MAX_CLOCK_SKEW: int

class Fernet:
    _signing_key: Any = ...
    _encryption_key: Any = ...
    _backend: Any = ...
    def __init__(self, key: bytes, backend: Any=...) -> None: ...
    @classmethod
    def generate_key(cls: Any) -> bytes: ...
    def encrypt(self, data: bytes) -> bytes: ...
    def encrypt_at_time(self, data: bytes, current_time: int) -> bytes: ...
    def _encrypt_from_parts(self, data: bytes, current_time: int, iv: bytes) -> bytes: ...
    def decrypt(self, token: bytes, ttl: typing.Optional[int]=...) -> bytes: ...
    def decrypt_at_time(self, token: bytes, ttl: int, current_time: int) -> bytes: ...
    def extract_timestamp(self, token: bytes) -> int: ...
    @staticmethod
    def _get_unverified_token_data(token: bytes) -> typing.Tuple[int, bytes]: ...
    def _verify_signature(self, data: bytes) -> None: ...
    def _decrypt_data(self, data: bytes, timestamp: int, time_info: typing.Optional[typing.Tuple[int, int]]) -> bytes: ...

class MultiFernet:
    _fernets: Any = ...
    def __init__(self, fernets: typing.Iterable[Fernet]) -> None: ...
    def encrypt(self, msg: bytes) -> bytes: ...
    def encrypt_at_time(self, msg: bytes, current_time: int) -> bytes: ...
    def rotate(self, msg: bytes) -> bytes: ...
    def decrypt(self, msg: bytes, ttl: typing.Optional[int]=...) -> bytes: ...
    def decrypt_at_time(self, msg: bytes, ttl: int, current_time: int) -> bytes: ...
